\chapter{文件系统库}\label{ch20}
直到C++17，Boost.Filesystem库终于被C++标准采纳。
在这个过程中，这个库用新的语言特性进行了很多调整、改进了和其他库的一致性、
进行了精简、还扩展了很多确实的功能（例如计算两个文件系统路径之间的相对路径）。

\section{基本的例子}
让我们以一些基本的例子开始。

\subsection{打印文件系统路径类的属性}
下面的程序允许我们传递一个字符串作为文件系统路径，然后根据给定路径的文件类型打印出一些信息：
\inputcodefile{filesystem/checkpath1.cpp}
我们首先把传入的命令行参数转换为了一个文件系统路径：
\begin{lstlisting}
    std::filesystem::path p{argv[1]};   // p代表一个文件系统路径（有可能不存在）
\end{lstlisting}
然后，我们进行了下列检查：
\begin{itemize}
    \item 如果改路径代表一个普通文件，我们打印出它的大小：
    \begin{lstlisting}
    if (is_regular_file(p)) {   // 路径p是普通文件？
        std::cout << p << " exists with " << file_size(p) << " bytes\n";
    }
    \end{lstlisting}
    像下面这样调用程序：
    \begin{lstlisting}
    checkpath checkpath.cpp
    \end{lstlisting}
    将会有如下输出：
    \begin{lstlisting}[stringstyle=\color{black}]
    "checkpath.cpp" exists with 907 bytes
    \end{lstlisting}
    注意输出路径时会自动把路径名用双引号括起来输出
    （把路径用双引号括起来、反斜杠用另一个反斜杠转义，
    \hyperref[ch20.1.1.1]{对Windows路径来说是一个问题}）。
    \item 如果路径是一个目录，我们迭代这个目录中的所有文件并打印出这些文件的路径：
    \begin{lstlisting}
    if (is_directory(p)) {      // 路径p是目录？
        std::cout << p << " is a directory containing:\n";
        for (auto& e : std::filesystem::directory_iterator{p}) {
            std::cout << "  " << e.path() << '\n';
        }
    }
    \end{lstlisting}
    这里，我们使用了\texttt{directory\_iterator}，
    它提供了\texttt{begin()}和\texttt{end()}，所以我们可以使用范围for循环来迭代
    \texttt{directory\_entry}元素。在这里，我们使用了\texttt{directory\_entry}的
    成员函数\texttt{path()}，返回该目录项的文件系统路径。
    像下面这样调用程序：
    \begin{lstlisting}
    checkpath .
    \end{lstlisting}
    输出将是：
    \begin{lstlisting}[stringstyle=\color{black}]
    "." is a directory containing:
      "./checkpath.cpp"
      "./checkpath.exe"
      ...
    \end{lstlisting}
    \item 最后，我们检查传入文件系统路径是否不存在：
    \begin{lstlisting}
    if (exists(p)) {        // 路径p存在吗？
        ...
    }
    \end{lstlisting}
\end{itemize}
注意根据\emph{参数依赖查找(argument dependent lookup)(ADL)}，
你不需要使用完全限定的名称来调用\texttt{is\_regular\_\\
file()}、\texttt{file\_size()}、\texttt{is\_directory()}、\texttt{exists()}等函数。
它们都属于命名空间\texttt{std::filesystem}，但是因为它们的参数也属于这个命名空间，
所以调用它们时会自动在这个命名空间中进行查找。

\subsubsection{在Windows下处理路径}\label{ch20.1.1.1}
（译者注：可能是水平有限，完全看不懂作者在这一小节的逻辑，
所以只能按照自己的理解胡乱翻译，如有错误请见谅。）

默认情况下，输出路径时用双引号括起来并用反斜杠转义反斜杠在Windows
下会导致一个问题。在Windows下以如下方式调用程序：
\begin{lstlisting}
    checkpath C:\
\end{lstlisting}
将会有如下输出：
\begin{lstlisting}[stringstyle=\color{black}]
    "C:" is a directory containing:
      ...
      "C:Users"
      "C:Windows"
\end{lstlisting}
用双引号括起来输出路径可以确保输出的文件名可以被直接复制粘贴到其他程序里，
并且经过转义之后还会恢复为原本的文件名。
然而，终端通常不接受这样的路径。

因此，一个在Windows下的可移植版本应该使用成员函数\texttt{string()}，
这样可以在向标准输出写入路径时避免输出双引号：
\inputcodefile{filesystem/checkpath2.cpp}
现在，在Windows上以下面方式调用程序：
\begin{lstlisting}
    checkpath C:\
\end{lstlisting}
将会有如下输出：
\begin{lstlisting}[stringstyle=\color{black}]
    "C:\" is a directory containing:
      ...
      "C:\Users"
      "C:\Windows"
\end{lstlisting}
通用字符串格式还提供了\hyperref[ch20.3.4]{其他转换}来把string转换为本地编码。

\subsection{用\texttt{switch}语句处理不同的文件系统类型}
我们可以像下面这样修改并改进上面的例子：
\inputcodefile{filesystem/checkpath3.cpp}

\subsubsection{命名空间\texttt{fs}}
首先，我们做了一个非常普遍的操作：我们定义了\texttt{fs}作为命名空间
\texttt{std::filesystem}的缩写：
\begin{lstlisting}
    namespace fs = std::filesystem;
\end{lstlisting}
使用新初始化的命名空间的一个例子是下面\texttt{switch}语句中的路径\texttt{p}：
\begin{lstlisting}
    fs::path p{argv[1]};
\end{lstlisting}
这里的\texttt{switch}语句使用了新的\nameref{ch2.2}特性，
初始化路径的同时把路径的类型作为分支条件：
\begin{lstlisting}
    switch (fs::path p{argv[1]}; status(p).type()) {
        ...
    }
\end{lstlisting}
表达式\texttt{status(p).type()}首先创建了一个\texttt{file\_status}对象，
然后该对象的\texttt{type()}方法返回了一个\texttt{file\_type}类型的值。
通过这种方式我们可以直接处理不同的类型，而不需要使用\texttt{is\_regular\_file()}、
\texttt{is\_directory()}等函数构成的if-else链。
我们通过多个步骤（先调用\texttt{status()}再调用\texttt{type()}才得到了最后的类型，
因此我们不需要为不感兴趣的其他信息付出多余的系统调用开销。

注意可能已经有特定实现的\texttt{file\_type}存在。例如，
Windows就提供了\hyperref[junction]{特殊的文件类型\texttt{junction}}。
然而，使用了它的代码是不可移植的。

\subsection{创建不同类型的文件}
在介绍了文件系统的只读操作之后，让我们给出首个进行修改的例子。
下面的程序在一个子目录\texttt{tmp}中创建了不同类型的文件：
\inputcodefile{filesystem/createfiles.cpp}
让我们一步步来分析这段程序。

\subsubsection{命名空间\texttt{fs}}
首先，我们又一次定义了\texttt{fs}作为命名空间\texttt{std::filesystem}的缩写：
\begin{lstlisting}
    namespace fs = std::filesystem;
\end{lstlisting}
之后我们使用这个命名空间为临时文件创建了一个基本的子目录：
\begin{lstlisting}
    fs::path testDir{"tmp/test"};
\end{lstlisting}

\subsubsection{创建目录}
当我们尝试创建子目录时：
\begin{lstlisting}
    create_directories(testDir);
\end{lstlisting}
通过使用\texttt{create\_directories()}我们可以递归创建整个路径中所有缺少的目录
（还有一个\texttt{create\_\\
directory()}只在已存在的目录中创建目录）。

当目标目录已经存在时这个调用并不会返回错误。
然而，其他的问题会导致错误病抛出一个相应的异常。

如果\texttt{testDis}已经存在，\texttt{create\_directories()}会返回\texttt{false}。
因此，你可以这么写：
\begin{lstlisting}
    if (!create_directories(testDir)) {
        std::cout << "\"" << testDir.string() << "\" already exists\n";
    }
\end{lstlisting}

\subsubsection{创建普通文件}
之后我们用一些内容创建了一个新文件\texttt{tmp/test/data.txt}：
\begin{lstlisting}
    auto testFile = testDir / "data.txt";
    std::ofstream dataFile{testFile};
    if (!dataFile) {
        std::cerr << "OOPS, can't open \"" << testFile.string() << "\"\n";
        std::exit(EXIT_FAILURE);  // 失败退出程序
    }
    dataFile << "The answer is 42\n";
\end{lstlisting}
这里，我们使用了运算符\texttt{/}来扩展路径，然后传递给文件流的构造函数。
如你所见，普通文件的创建可以使用现有的I/O流库来实现。
然而，I/O流的构造函数多了一个以文件系统路径为参数的版本
（一些函数例如\texttt{open()}也添加了这种重载版本）。

注意你仍然应该总是检查创建/打开文件的操作是否成功了。
这里有很多种可能发生的错误（\hyperref[ch20.1.3.6]{见下文}）。

\subsubsection{创建符号链接}
接下来的语句尝试尝试创建符号链接\texttt{tmp/slink}指向目录\texttt{tmp/test}：
\begin{lstlisting}
    create_directory_symlink("test", testDir.parent_path() / "slink");
\end{lstlisting}
注意第一个参数的路径是以即将创建的符号链接所在的目录为起点的相对路径。
因此，你必须传递\texttt{"test"}而不是\texttt{"tmp/test"}来高效的
创建链接\texttt{tmp/slink}指向\texttt{tmp/test}。如果你调用：
\begin{lstlisting}
    std::filesystem::create_directory_symlink("tmp/test", "tmp/slink");
\end{lstlisting}
你将会高效的创建符号链接\texttt{tmp/slink}，然而它会指向\texttt{tmp/tmp/test}。

注意通常情况下，也可以调用\texttt{create\_symlink()}代替\texttt{create\_
directory\_symlink()}来创建目录的符号链接。
然而，一些操作系统可能对目录的符号链接有特殊处理或者当知道要创建的符号链接指向目录时会有优化，
因此，当你想创建指向目录的符号链接时你应该使用\texttt{create\_directory\_
symlink()}。

最后，注意这个调用在Windows上可能会失败并导致\hyperref[创建链接失败]{错误处理}，
因为创建符号链接可能需要管理员权限。

\subsubsection{递归遍历目录}
最后，我们递归的遍历了当前目录：
\begin{lstlisting}
    auto iterOpts = fs::directory_options::follow_directory_symlink;
    for (auto& e : fs::recursive_directory_iterator(".", iterOpts)) {
        std::cout << "  " << e.path().lexically_normal().string() << '\n';
    }
\end{lstlisting}
注意我们使用了一个递归目录迭代器并传递了选项\texttt{follow\_directory\_
symlink}来遍历符号链接。因此，我们在POSIX兼容系统上可能会得到类似于如下输出：
\begin{lstlisting}
    /home/nico:
      ...
      tmp
      tmp/slink
      tmp/slink/data.txt
      tmp/test
      tmp/test/data.txt
      ...
\end{lstlisting}
在Windows系统上有类似如下输出：
\begin{lstlisting}
    C:\Users\nico:
      ...
      tmp
      tmp\slink
      tmp\slink\data.txt
      tmp\test
      tmp\test\data.txt
      ...
\end{lstlisting}
注意在我们打印目录项之前调用了\texttt{lexically\_normal()}。
如果略过这一步，目录项的路径可能会包含一个前缀，
这个前缀是创建目录迭代器时传递的实参。
因此，在循环内直接打印路径：
\begin{lstlisting}
    auto iterOpts = fs::directory_options::follow_directory_symlink;
    for (auto& e : fs::recursive_directory_iterator(".", iterOpts)) {
        std::cout << "  " << e.path() << '\n';
    }
\end{lstlisting}
将会在POSIX兼容系统上有如下输出：
\begin{lstlisting}[stringstyle=\color{black}]
    all files:
      ...
      "./testdir"
      "./testdir/data.txt"
      "./tmp"
      "./tmp/test"
      "./tmp/test/data.txt"
\end{lstlisting}
在Windows上，输出将是：
\begin{lstlisting}[stringstyle=\color{black}]
    all files:
      ...
      ".testdir"
      ".testdirdata.txt"
      ".tmp"
      ".tmptest"
      ".tmptestdata.txt"
\end{lstlisting}
通过调用\texttt{lexically\_normal()}我们可以得到正规化的路径，
它移除了前导的代表当前路径的点。还有，\hyperref[ch20.1.1.1]{如上文所述}，
通过调用\texttt{string()}我们避免了输出路径时用双引号括起来。
这里没有调用\texttt{string()}的输出结果在POSIX兼容的系统上看起来OK（只是路径两端有双引号），
但在Windows上的结果看起来就很奇怪（因为每一个反斜杠都需要反斜杠转义）。

\subsubsection{错误处理}\label{ch20.1.3.6}
文件系统往往是麻烦的根源。你可能因为在文件名中使用了无效的字符而导致操作失败，
或者当你正在访问文件系统时它已经被其他程序修改了。
因此，根据平台和权限的不同，这个程序中可能会有很多问题。

对于那些没有被返回值覆盖的情况（例如当目录已经存在时），
我们捕获了相应的异常并打印了一般的信息和第一个路径：
\begin{lstlisting}
    try {
        ...
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "EXCEPTION: " << e.what() << '\n';
        std::cerr << "    path1: \"" << e.path1().string() << "\"\n";
    }
\end{lstlisting}
例如，如果我们不能创建目录，将会打印出类似于如下消息：
\begin{lstlisting}[stringstyle=\color{black}]
    EXCEPTION: filesystem error: cannot create directory: [tmp/test]
        path1: "tmp/test"
\end{lstlisting}
如果我们不能创建符号链接可能是因为它已经存在了，
或者我们可能需要特殊权限，这些情况下你可能会得到如下消息：\label{创建链接失败}
\begin{lstlisting}[stringstyle=\color{black}]
    EXCEPTION: create_directory_symlink: Can't create a file when it
                                         already exists: "tmp\test\
                                         data.txt", "testdir"
        path1: "tmp\test\data.txt"
\end{lstlisting}
或者：
\begin{lstlisting}[stringstyle=\color{black}, keywordstyle=\color{black}]
    EXCEPTION: create_directory_symlink: A requied privilege is not
                                         held by the client.: "test
                                         ", "tmp\slink"
        path1: "test"
\end{lstlisting}
在每一种情况下，都要注意在多用户/多进程操作系统中情况可能会在任何时候改变，
这意味着你刚刚创建的目录甚至可能已经被删除、重命名、或已经被同名的文件覆盖。
因此，很显然不能只根据当前的情况就保证一个预期操作一定是有效的。
最好的方式就是尝试做想做的操作（例如，创建目录、打开文件）
并处理抛出的异常和错误，或者验证预期的行为。

然而，有些时候文件系统操作能正常执行但不是按你预想的结果。
例如，如果你想在指定目录中创建一个文件并且已经有了一个和目录同名的指向另一个目录的符号链接，
那么这个文件可能在一个预料之外的地方创建或者覆写。
（译者注：比如你想在当前目录下递归创建"a/b"，
但已经有了一个"a"是一个指向"c"目录的符号链接，这时你实际会在目录"c"下创建"b"）
这种情况是有可能的（用户完全有可能会创建目录的符号链接），但是如果你想检测这种情况，
在创建文件之前你需要\nameref{ch20.4.1.1}（这可能比你一开始想的要复杂很多）。

再强调一次：文件系统并不保证进行处理之前的检查的结果直到你进行处理时仍然有效。

\subsection{使用并行算法处理文件系统}
参见\hyperref[ch22.6.1.4]{dirsize.cpp}
查看另一个使用并行算法计算目录树中所有文件大小之和的例子。


\section{原则和术语}
在讨论文件系统库的细节之前，我们不得不继续介绍一些设计原则和术语。
这是必须的，因为标准库要覆盖不同的操作系统并把系统提供的接口映射为公共的API。

\subsection{通用的可移植的分隔符}
C++标准库不仅标准化了所有操作系统的文件系统中公共的部分，在很多情况下，
C++标准还尽可能的遵循POSIX标准的要求来实现。
对于一些操作，只要是合理的就应该能正确执行，如果操作是不合理的，实现应该报错。
这些错误可能是：
\begin{itemize}
    \item 特殊的字符不能被用作文件名
    \item 文件系统的某些元素不支持创建（例如，符号链接）
\end{itemize}
不同文件系统的差异也应该纳入考虑：
\begin{itemize}
    \item 大小写敏感：
    \texttt{"hello.txt"}和\texttt{"Hello.txt"}和\texttt{"hello.TXT"}可能指向
    同一个文件（Windows上）也可能指向三个不同的文件（POSIX兼容系统）。
    \item 绝对路径和相对路径：
    \item 在某些系统上，"/bin"是一个绝对路径（POSIX兼容系统），
    然而在某些系统上不是（Windows）。
\end{itemize}

\subsection{命名空间}
文件系统库在\texttt{std}里有自己的子命名空间\texttt{filesystem}。
一个很常见的操作是定义缩写\texttt{fs}：
\begin{lstlisting}
    namespace fs = std::filesystem;
\end{lstlisting}
这允许我们使用\texttt{fs::current\_path()}代替\texttt{std::filesystem::
current\_path()}。

这一章的示例代码中将经常使用\texttt{fs}作为缩写。

注意你应该总是使用完全限定的函数调用，尽管不指明命名空间时通过
\emph{参数依赖查找(argument dependent lookup)(ADL)}也能够工作。
但如果不用命名空间限定有时可能\hyperref[ADL导致意外行为]{导致意外的行为}。

\subsection{文件系统路径}\label{ch20.2.3}
文件系统库的一个关键元素是\texttt{path}。它代表文件系统中某一个文件的名字。
它由可选的根名称、可选的根目录、和一些以目录分隔符分隔的文件名组成。
路径可以是相对的（此时文件的位置依赖于当前的工作目录）或者是绝对的。

路径可能有不同的格式：
\begin{itemize}
    \item 通过格式，这是可移植的
    \item 本地格式，这是底层文件系统特定的
\end{itemize}
在POSIX兼容系统上通用格式和本地格式没有什么区别。
在Windows上，通用格式\texttt{/tmp/test.txt}也是有效的本地格式，
另外\texttt{\textbackslash tmp\textbackslash test.txt}也是有效的
（\texttt{/tmp/test.txt}和\texttt{\textbackslash tmp\textbackslash test.txt}
是同一个路径的两种本地版本）。在OPenVMS上，相应的本地格式将是\texttt{[tmp]test.txt}。

也有一些特殊的文件名：
\begin{itemize}
    \item "."代表当前mulu
    \item ".."代表父目录
\end{itemize}
通用的路径格式如下：
\begin{lstlisting}
    [rootname] [rootdir] [relativepath]
\end{lstlisting}
这里：
\begin{itemize}
    \item 可选的根名称是实现特定的（例如，在POSIX系统上可以是\texttt{//host}，而在Windows上可以是C:）
    \item 可选的根目录是一个目录分隔符
    \item 相对路径是若干目录分隔符分隔的文件名
\end{itemize}
目录分隔符由一个或多个\texttt{'/'}组成或者是实现特定的。

可移植的通用路径的例子有：
\begin{lstlisting}[commentstyle=\color{black}]
    //host1/bin/hello.txt
    .
    tmp/
    /a/b//.../c
\end{lstlisting}
注意在POSIX系统上最后一个路径和\texttt{/a/c}指向同一个位置，并且都是绝对路径。
而在Windows上则是相对路径（因为没有指定驱动器/分区（盘））。

另一方面，\texttt{C:/bin}在Windows上是绝对路径（在"C"盘上的根目录\texttt{"bin"}），
但在POSIX系统上是一个相对路径（目录"C:"下的子目录"bin"）。

在Windows系统上，反斜杠是实现特定的目录分隔符，
因此上面的路径\emph{也}可以使用反斜杠作为目录分隔符：
\begin{lstlisting}
    host1\bin\hello.txt
    .
    tmp\
    \a\b\..\c
\end{lstlisting}
文件系统库提供了\hyperref[ch20.3.4]{在本地格式和通用格式之间转换的函数}。

一个\texttt{path}可能为空，这意味着没有定义路径。
这种状态的含义\emph{不}需要和\texttt{"."}一样。它的含义依赖于上下文。

\subsection{正规化}
路径可以进行正规化，在正规化的路径中：
\begin{itemize}
    \item 文件名由单个推荐的目录分隔符分隔。
    \item 除非整个路径就是\texttt{"."}（代表当前目录），否则路径中不会使用\texttt{"."}。
    \item 路径中除了开头以外的地方不会包含\texttt{".."}（不能在路径中上下徘徊）。
    \item 除非整个路径就是\texttt{"."}或者\texttt{".."}，否则当路径结尾的文件名是目录时要在最后加上目录分隔符。
\end{itemize}
注意正规化之后以目录分隔符结尾的路径和不以目录分隔符结尾的路径是不同的。
这是因为在某些操作系统中，当它们知道目标路径是一个目录时行为可能会发生改变
（例如，有尾部的分隔符时符号链接将被解析）。

表\hyperref[t20.1]{路径正规化的效果}列举了一些在POSIX系统和Windows系统上
对路径进行正规化的例子。注意再重复一次，在POSIX系统上，\texttt{C:bar}和\texttt{C:}只是
把冒号作为文件名的一部分的单个文件名，并没有特殊的含义，而在Windows上，它们指定了一个分区。
\begin{table}[ht]
    \begin{tabular}{l|l|p{0.35\textwidth}}
        \hline
        \textbf{路径}                                    & \textbf{POSIX正规化}                              & \textbf{Windows正规化}                                               \\
        \hline
        \texttt{foo/.///bar/../}                       & \texttt{foo/}                                  & \texttt{foo\textbackslash}                                        \\
        \texttt{//host/../foo.txt}                     & \texttt{//host/foo.txt}                        & \texttt{\textbackslash \textbackslash host\textbackslash foo.txt} \\
        \texttt{./f/../.f/}                            & \texttt{.f/}                                   & \texttt{.f\textbackslash}                                         \\
        \texttt{C:bar/../}                             & \texttt{.}                                     & \texttt{C:}                                                       \\
        \texttt{C:/bar/..}                             & \texttt{C:/}                                   & \texttt{C:\textbackslash}                                         \\
        \texttt{C:\textbackslash bar\textbackslash ..} & \texttt{C:\textbackslash bar\textbackslash ..} & \texttt{C:\textbackslash}                                         \\
        \texttt{/./../data.txt}                        & \texttt{/data.txt}                             & \texttt{\textbackslash data.txt}                                  \\
        \texttt{././}                                  & \texttt{.}                                     & \texttt{.}                                                        \\
        \hline
    \end{tabular}
    \caption{路径正规化的效果}
    \label{t20.1}
\end{table}

文件系统库同时提供了\hyperref[ch20.3.3]{词法正规化}（不考虑文件系统）
和\hyperref[ch20.4.5]{依赖文件系统的正规化}两种方式的相关函数。

\subsection{成员函数VS独立函数}
文件系统库提供了一些函数，有些是成员函数有些是独立函数。这么做的目的是：
\begin{itemize}
    \item \textbf{成员函数开销较小}。这是因为它们是纯词法的操作，并不会考虑实际的文件系统，
    这意味着它们不需要进行操作系统调用。例如：
    \begin{lstlisting}
        mypath.is_absolute()        // 检查路径是否是绝对的
    \end{lstlisting}
    \item \textbf{独立函数开销较大}。因为它们通常会考虑实际的文件系统，
    这意味着需要进行操作系统调用。例如：
    \begin{lstlisting}
        equivalent(path1, path2);   // 如果两个路径指向同一个文件则返回true
    \end{lstlisting}
\end{itemize}
有时，文件系统库甚至为同一个功能既提供根据词法的版本又提供考虑实际文件系统的版本：
\begin{lstlisting}
    std::filesystem::path fromP, toP;
    ...
    toP.lexically_relative(fromP);  // 返回从fromP到toP的词法路径
    relative(toP, fromP);           // 返回从fromP到toP的实际路径
\end{lstlisting}
得益于\emph{参数依赖查找(ADL)}，很多情况下当调用独立函数时你不需要指明完整命名空间
\texttt{std::filesystem}，只要参数是文件系统库里定义的类型。只有当用其它类型隐式转换
为参数时时你才需要给出完全限定的函数名。例如：\label{ADL导致意外行为}
\begin{lstlisting}
    create_directory(std::filesystem::path{"tmpdir"});  // OK
    remove(std::filesystem::path{"tmpdir"});            // OK
    std::filesystem::create_directory("tmpdir");        // OK
    std::filesystem::remove("tmpdir");                  // OK
    create_directory("tmpdir");                         // ERROR
\end{lstlisting}
最后一个调用将会编译失败，因为我们并没有传递文件系统命名空间里的类型作为参数，
因此也不会在该命名空间里查找符号\texttt{create\_directory}。

然而，这里有一个著名的陷阱：
\begin{lstlisting}
    remove("tmpdir");   // OOPS：调用C函数remove()
\end{lstlisting}
根据你包含的头文件，这个调用可能会找到C函数\texttt{remove()}，
它的行为有一些不同：它也会删除指定的文件但不会删除空目录。

因此，强烈推荐使用完全限定的文件系统库里的函数名。例如：
\begin{lstlisting}
    namespace fs = std::filesystem;
    ...
    fs::remove("tmpdir");   // OK：调用C++文件系统库函数remove()
\end{lstlisting}

\subsection{错误处理}
\hyperref[ch20.1.3.6]{如上文所述}，文件系统是错误的根据。
你必须考虑相应的文件是否存在、文件的操作是否被允许、该操作是否会违背资源限制。
另外，当程序运行时其它进程可能创建、修改、或者移除了某些文件，这意味着事先检查
并不能保证没有错误。

问题在于从理论上讲，你不能提前保证下一次文件系统操作能够成功。
任何事先检查的结果都可能在你实际进行处理时失效。
因此，最好的方法是在进行一个或多个文件系统操作时处理好相应的异常或者错误。

注意，当读写普通文件时，默认情况下I/O流并不会抛出异常或错误。
当操作遇到错误时它只会什么也不做。因此，建议至少检查一下文件是否被成功打开。

因为并不是所有情况下都适合抛出异常（例如当一个文件系统调用失败时你想直接处理），
所以文件系统库使用了混合的异常处理方式：
\begin{itemize}
    \item 默认情况下，文件系统错误会作为异常处理。
    \item 然而，如果你想的话可以在本地处理具体的某一个错误。
\end{itemize}
因此，文件系统库通常为每个操作提供两个重载版本：
\begin{enumerate}
    \item 默认情况下（没有额外的错误处理参数），出现错误时抛出\texttt{filesystem\_error}异常。
    \item 传递额外的输出参数时，可以得到一个错误码或错误信息，而不是异常。
\end{enumerate}
注意在第二种情况下，你可能会得到一个特殊的返回值来表示特定的错误。

\subsubsection{使用\texttt{filesystem\_error}异常}
例如，你可以尝试像下面这样创建一个目录：
\begin{lstlisting}
    if (!create_directory(p)) { // 发生错误时抛出异常（除非错误是该路径已经存在）
        std::cout << p << " already exists\n";  // 该路径已经存在
    }
\end{lstlisting}
这里没有传递错误码参数，因此错误时通常会抛出异常。
然而，注意当目录已存在时这种特殊情况是直接返回\texttt{false}。
因此，只有当其他错误例如没有权限创建目录、路径\texttt{p}无效、
违反了文件系统限制（例如路径长度超过上限）时才会抛出异常。

可以直接或间接的用\texttt{try-catch}包含这段代码，
然后处理\texttt{std::filesystem::filesystem\_error}异常：
\begin{lstlisting}
    try {
        ...
        if (!create_directory(p)) { // 错误时抛出异常（除非错误是该路径已经存在）
            std::cout << p << " already exists\n"; // 该路径已经存在
        }
        ...
    }
    catch (const std::filesystem::filesystem_error& e) { // 派生自std::exception
        std::cout << "EXCEPTION: " << e.what() << '\n';
        std::cout << "     path: " << e.path1() << '\n';
    }
\end{lstlisting}
如你所见，文件系统异常提供了标准异常的\texttt{what()}函数API来返回一个
实现特定的错误信息。然而，API还提供了\texttt{path1()}来获取错误相关的第一个路径，
和\texttt{path2()}来获取相关的第二个路径。

\subsubsection{使用\texttt{error\_code}参数}
另一种创建目录的方式如下所示：
\begin{lstlisting}
    std::error_code ec;
    create_directory(p, ec);    // 发生错误时设置错误码
    if (ec) {                   // 如果设置了错误码（因为发生了错误）
        std::cout << "ERROR: " << ec.message() << "\n";
    }
\end{lstlisting}
之后，我们还可以检查特定的错误码：
\begin{lstlisting}
    if (ec == std::errc::read_only_file_system) {   // 如果设置了特定的错误码
        std::cout << "ERROR: " << p << " is read-only\n";
    }
\end{lstlisting}
注意这种情况下，我们仍然必须检查\texttt{create\_directory()的返回值}：
\begin{lstlisting}
    std::error_code ec;
    if (!create_directory(p, ec)) { // 发生错误时设置错误码
        // 发生任何错误时
        std::cout << "can't create directory " << p << "\n";
        std::cout << "error: " << ec.message() << "\n";
    }
\end{lstlisting}
然而，并不是所有的文件系统操作都提供这种能力（因为它们在正常情况下会返回一些值）。

类型\texttt{error\_code}由C++11引入，它包含了一系列可移植的错误条件例如
\texttt{std::errc::read\_only\_\\
filesystem}。在POSIX兼容的系统上这些被
映射为\texttt{errno}的值。

\subsection{文件类型}
不同的操作系统支持不同的文件类型。标准文件系统库中也考虑到了这一点，它定义了一个
枚举类型\texttt{file\_type}，标准中定义了如下的值：
\begin{lstlisting}
    namespace std::filesystem {
        enum class file_type {
            regular, directory, symlink,
            block, character, fifo, socket,
            ...
            none, not_found, unknown,
        };
    }
\end{lstlisting}
表\hyperref[t20.2]{\texttt{file\_type}的值}列出了这些值的含义。
\begin{table}[ht]
    \begin{tabular}{l|p{0.7\textwidth}}
        \hline
        \textbf{值}          & \textbf{含义}   \\
        \hline
        \texttt{regular}    & 普通文件          \\
        \texttt{directory}  & 目录文件          \\
        \texttt{symlink}    & 符号链接文件        \\
        \texttt{character}  & 字符特殊文件        \\
        \texttt{block}      & 块特殊文件         \\
        \texttt{fifo}       & FIFO或者管道文件    \\
        \texttt{socket}     & 套接字文件         \\
        \ldots              & 附加的实现定义的文件类型  \\
        \texttt{none}       & 文件的类型未知       \\
        \texttt{unknown}    & 文件存在但推断不出类型   \\
        \texttt{not\_found} & 虚拟的表示文件不存在的类型 \\
        \hline
    \end{tabular}
    \caption{文件系统类型的值}
    \label{t20.2}
\end{table}

操作系统平台可能会提供附加的文件类型值。然而，使用它们是不可移植的。
例如，Windows就提供了文件类型值\texttt{junction}，它被用于NTFS文件系统中的
\emph{NTFS junctions}（也被称为软链接）。
它们被用作链接来访问同一台电脑上不同的子卷(盘)。\label{junction}

除了普通文件和目录之外，最常见的类型是符号链接，它是一种指向另一个位置的文件。
指向的为之可能有一个文件也可能没有。注意有些操作系统和/或文件系统（例如FAT文件系统）
完全不支持符号链接。有些操作系统只支持普通文件的符号链接。
注意在Windows上需要特殊的权限才能创建符号链接，可以用\texttt{mklink}命令创建。

字符特殊文件、块特殊文件、FIFO、套接字都来自于UNIX文件系统。
目前，Visual C++并没有使用这四种类型中的任何一个。
\footnote{Windows管道的行为有些不同，也不被识别为\texttt{fifo}。}

如你所见，有一些特殊的值来表示文件不存在或者类型未知或者无法探测出类型。

在这一章的剩余部分我将使用两种广义的类型来代表相应的若干文件类型：
\begin{itemize}
    \item \emph{其他文件}：除了普通文件、目录、符号链接之外的所有类型的文件。
    库函数\texttt{is\_other()}和这个术语相匹配。
    \item \emph{特殊文件}：下列类型的文件：字符特殊文件、块特殊文件、FIFO、套接字。
\end{itemize}
另外，\emph{特殊}文件类型加上实现定义的文件类型就构成了\emph{其他}文件类型。

\section{路径操作}

\subsection{创建路径}

\subsection{检查路径}

\subsubsection{迭代路径}

\subsection{路径I/O和转换}\label{ch20.3.3}
\subsubsection{路径I/O}
\subsubsection{正规化}
\subsubsection{相对路径}
\subsubsection{转换为字符串}

\subsection{本地和通用格式的转换}\label{ch20.3.4}

\subsection{修改路径}

\subsection{比较路径}

\subsection{其他路径操作}


\section{文件系统操作}

\subsection{文件属性}
\subsubsection{检查文件是否存在}\label{ch20.4.1.1}
\subsubsection{其他文件属性}
\subsubsection{处理最后修改的时间}

\subsection{文件状态}

\subsection{权限}

\subsection{修改文件系统}
\subsubsection{创建和删除文件}
\subsubsection{修改已存在的文件}

\subsection{符号链接和依赖文件系统的路径的转换}\label{ch20.4.5}

\subsection{其他文件系统操作}


\section{迭代目录}
\subsubsection{目录迭代器表示一个范围}
\subsubsection{目录迭代器选项}

\subsection{目录项}
\subsubsection{目录项缓存}


\section{后记}